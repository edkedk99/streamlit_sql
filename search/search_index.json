{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"streamlit_sql","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Creating a CRUD interface can be a tedious and repetitive task. This package is intended to replace all of that with a few lines of code that involves simply creating a sqlalchemy statement and calling the main SqlUi class with only 3 required arguments. All extra and advanced features are available by supplying non-required arguments to the class initialization.</p> <p>When the main class is initialized, it will display the database table data with most of the expected features of a crud interface, so the user will be able to read, filter, update, create and delete rows with many useful features.</p>"},{"location":"#demo","title":"Demo","text":"<p>See the package in action here.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#read","title":"READ","text":"<ul> <li>Display as a regular st.dataframe</li> <li>Add pagination, displaying only a set of rows each time</li> <li>Set the dataframe to be displayed using standard sqlalchemy select statement, where you can JOIN, ORDER BY, WHERE, etc.</li> <li>Add a column to show the rolling sum of a numeric column</li> <li>Conditional styling if the DataFrame based on each row value. For instance, changing its background color</li> </ul>"},{"location":"#filter","title":"FILTER","text":"<ul> <li>Filter the data by some columns before presenting the table.</li> <li>Let users filter the columns by selecting conditions in the filter expander</li> <li>Give possible candidates when filtering using existing values for the columns</li> <li>Let users select ForeignKey's values using the string representation of the foreign table, instead of its id number</li> </ul>"},{"location":"#update","title":"UPDATE","text":"<ul> <li>Users update rows with a dialog opened by selecting the row and clicking the icon</li> <li>Text columns offers candidates from existing values</li> <li>ForeignKey columns are added by the string representation instead of its id number</li> <li>In Update form, list all ONE-TO-MANY related rows with pagination, where you can directly create and delete related table rows. </li> <li>Log updates to database to stderr or in anyway loguru can handle</li> </ul>"},{"location":"#create","title":"CREATE","text":"<ul> <li>Users create new rows with a dialog opened by clicking the create button</li> <li>Text columns offers candidates from existing values</li> <li>Hide columns to fill by offering default values</li> <li>ForeignKey columns are added by the string representation instead of its id number</li> </ul>"},{"location":"#delete","title":"DELETE","text":"<ul> <li>Delete one or multiple rows by selecting in DataFrame and clicking the corresponding button. A dialog will list selected rows and confirm deletion.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>All the requirements you should probably have anyway.</p> <ol> <li>streamlit and sqlalchemy</li> <li>Sqlalchemy models needs a str method</li> <li>Id column should be called \"id\"</li> <li>Relationships should be added for all ForeignKey columns </li> </ol>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Install the package using pip:</p> <pre><code>pip install streamlit_sql\n</code></pre> <p>Run <code>show_sql_ui</code> as the example below:</p> <pre><code>from streamlit_sql import show_sql_ui\nfrom sqlalchemy import select\n\nconn = st.connection(\"sql\", url=\"&lt;db_url&gt;\")\n\nstmt = (\n    select(\n        db.Invoice.id,\n        db.Invoice.Date,\n        db.Invoice.amount,\n        db.Client.name,\n    )\n    .join(db.Client)\n    .where(db.Invoice.amount &gt; 1000)\n    .order_by(db.Invoice.date)\n)\n\nshow_sql_ui(conn=conn,\n            read_instance=stmt,\n            edit_create_model=db.Invoice,\n            available_filter=[\"name\"],\n            rolling_total_column=\"amount\",\n)\n\nshow_sql_ui(conn, model_opts)\n</code></pre> <p>Warning</p> <p>In the statement, always include the primary_key column, that should be named id</p>"},{"location":"#interface","title":"Interface","text":"<ul> <li>Filter: Open the \"Filter\" expander and fill the inputs</li> <li>Add row: Click on \"plus\" button (no dataframe row can be selected)</li> <li>Edit row: Click on \"pencil\" button (one and only one dataframe row should be selected)</li> <li>Delete row: Click on \"trash\" button (one or more dataframe rows should be selected)</li> </ul>"},{"location":"#customize","title":"Customize","text":"<p>You can adjust the CRUD interface by the select statement you provide to read_instance arg and giving optional arguments to the show_sql_ui function. See the docstring for more information or at documentation webpage:</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#api","title":"API","text":""},{"location":"api/#streamlit_sql.SqlUi","title":"<code>SqlUi</code>","text":"<p>Show A CRUD interface in a Streamlit Page</p> <p>See in init method detailed descriptions of arguments and properties</p> <p>It also offers the following properties:</p> Source code in <code>streamlit_sql/sql_iu.py</code> <pre><code>class SqlUi:\n    \"\"\"Show A CRUD interface in a Streamlit Page\n\n    See in __init__ method detailed descriptions of arguments and properties\n\n    It also offers the following properties:\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        conn: SQLConnection,\n        read_instance,\n        edit_create_model: type[DeclarativeBase],\n        available_filter: list[str] | None = None,\n        edit_create_default_values: dict | None = None,\n        rolling_total_column: str | None = None,\n        df_style_formatter: dict[str, str] | None = None,\n        read_use_container_width: bool = False,\n        hide_id: bool = True,\n        base_key: str = \"\",\n        style_fn: Callable[[pd.Series], list[str]] | None = None,\n        update_show_many: bool = False,\n        disable_log: bool = False,\n    ):\n        \"\"\"The CRUD interface will be displayes just by initializing the class\n\n        Arguments:\n            conn (SQLConnection): A sqlalchemy connection created with st.connection(\\\"sql\\\", url=\\\"&lt;sqlalchemy url&gt;\\\")\n            read_instance (Select | CTE | Model): The sqlalchemy select statement to display or a CTE. Choose columns to display , join, query or order.If selecting columns, you need to add the id column. If a Model, it will select all columns.\n            edit_create_default_values (dict, optional): A dict with column name as keys and values to be default. When the user clicks to create a row, those columns will not show on the form and its value will be added to the Model object\n            available_filter (list[str], optional): Define wich columns the user will be able to filter in the top exapander. Defaults to all\n            rolling_total_column (str, optional): A numeric column name of the read_instance. A new column will be displayed with the rolling sum of these column\n            df_style_formatter (dict[str,str]): a dictionary where each key is a column name and the associated value is the formatter arg of df.style.format method. See pandas docs for details.\n            read_use_container_width (bool, optional): add use_container_width to st.dataframe args. Default to False\n            hide_id (bool, optional): The id column will not be displayed if set to True. Defaults to True\n            base_key (str, optional): A prefix to add to widget's key argument. This is needed when creating more than one instance of this class in the same page. Defaults to empty str\n            style_fn (Callable[[pd.Series], list[str]], optional): A function that goes into the *func* argument of *df.style.apply*. The apply method also receives *axis=1*, so it works on rows. It can be used to apply conditional css formatting on each column of the row. See Styler.apply info on pandas docs. Defaults to None\n            update_show_many (bool, optional): Show a st.expander of one-to-many relations in edit or create dialog\n            disable_log (bool): Every change in the database (READ, UPDATE, DELETE) is logged to stderr by default. If this is *true*, nothing is logged. To customize the logging format and where it logs to, use loguru as add a new sink to logger. See loguru docs for more information. Dafaults to False\n\n        Attributes:\n            df (pd.Dataframe): The Dataframe displayed in the screen\n            selected_rows (list[int]): The position of selected rows. This is not the row id.\n            qtty_rows (int): The quantity of all rows after filtering\n\n\n        Examples:\n            ```python\n            def style_fn(row):\n                if row.amount &gt; 0:\n                    bg = \"background-color: rgba(0, 255, 0, 0.1)\"\n                else:\n                    bg = \"background-color: rgba(255, 0, 0, 0.2)\"\n\n                result = [bg] * len(row)\n                return result\n\n\n            db_url = \"sqlite:///data.db\"\n            conn = st.connection(\"sql\", db_url)\n\n            stmt = (\n                select(\n                    db.Invoice.id,\n                    db.Invoice.Date,\n                    db.Invoice.amount,\n                    db.Client.name,\n                )\n                .join(db.Client)\n                .where(db.Invoice.amount &gt; 1000)\n                .order_by(db.Invoice.date)\n            )\n\n            sql_ui = SqlUi(\n                conn=conn,\n                read_instance=stmt,\n                edit_create_model=db.Invoice,\n                available_filter=[\"name\"],\n                rolling_total_column=\"amount\",\n                df_style_formatter={\"amount\": \"{:,.2f}\"},\n                read_use_container_width=True,\n                hide_id=True,\n                base_key=\"my_base_sql_ui\",\n                style_fn=style_fn,\n                update_show_many=True,\n                disable_log=False,\n            )\n\n            ```\n\n        \"\"\"\n        self.conn = conn\n        self.read_instance = read_instance\n        self.edit_create_model = edit_create_model\n        self.available_filter = available_filter or []\n        self.edit_create_default_values = edit_create_default_values or {}\n        self.rolling_total_column = rolling_total_column\n        self.df_style_formatter = df_style_formatter or {}\n        self.read_use_container_width = read_use_container_width\n        self.hide_id = hide_id\n        self.base_key = base_key\n        self.style_fn = style_fn\n        self.update_show_many = update_show_many\n        self.disable_log = disable_log\n\n        self.cte = self.get_cte()\n        self.rolling_pretty_name = lib.get_pretty_name(self.rolling_total_column or \"\")\n\n        # Bootstrap\n        self.set_initial_state()\n        self.set_structure()\n        self.notification()\n        lib.set_logging(self.disable_log)\n\n        # Create UI\n        col_filter = self.filter()\n        stmt_no_pag = read_cte.get_stmt_no_pag(self.cte, col_filter)\n        initial_balance = self.get_initial_balance(stmt_no_pag, col_filter)\n        qtty_rows = read_cte.get_qtty_rows(self.conn, stmt_no_pag)\n        items_per_page, page = self.pagination(qtty_rows, col_filter)\n        stmt_pag = read_cte.get_stmt_pag(stmt_no_pag, items_per_page, page)\n        df = self.get_df(stmt_pag, initial_balance)\n        selection_state = self.show_df(df)\n        rows_selected = self.get_rows_selected(selection_state)\n\n        # CRUD\n        self.crud(df, rows_selected)\n        ss.stsql_opened = False\n\n        # Returns\n        self.df = df\n        self.rows_selected = rows_selected\n        self.qtty_rows = qtty_rows\n\n    def set_initial_state(self):\n        lib.set_state(\"stsql_updated\", 1)\n        lib.set_state(\"stsql_update_ok\", None)\n        lib.set_state(\"stsql_update_message\", None)\n        lib.set_state(\"stsql_opened\", False)\n        lib.set_state(\"stsql_filters\", {})\n\n    def set_structure(self):\n        self.header_container = st.container()\n        self.data_container = st.container()\n        self.pag_container = st.container()\n\n        table_name = lib.get_pretty_name(self.edit_create_model.__tablename__)\n        self.header_container.header(table_name, divider=\"orange\")\n\n        self.expander_container = self.header_container.expander(\n            \"Filter\",\n            icon=\":material/search:\",\n        )\n\n        self.filter_container = self.header_container.container()\n\n        if self.rolling_total_column:\n            self.saldo_toggle_col, self.saldo_value_col = self.header_container.columns(\n                2\n            )\n\n        self.btns_container = self.header_container.container()\n\n    def notification(self):\n        if ss.stsql_update_ok is True:\n            self.header_container.success(\n                ss.stsql_update_message, icon=\":material/thumb_up:\"\n            )\n        if ss.stsql_update_ok is False:\n            self.header_container.error(\n                ss.stsql_update_message, icon=\":material/thumb_down:\"\n            )\n\n    def get_cte(self):\n        if isinstance(self.read_instance, Select):\n            cte = self.read_instance.cte()\n        elif isinstance(self.read_instance, CTE):\n            cte = self.read_instance\n        else:\n            cte = select(self.read_instance).cte()\n\n        return cte\n\n    def filter(self):\n        filter_colsname = self.available_filter\n        if len(filter_colsname) == 0:\n            filter_colsname = [\n                col.description for col in self.cte.columns if col.description\n            ]\n\n        with self.conn.session as s:\n            existing = read_cte.get_existing_values(\n                _session=s,\n                cte=self.cte,\n                updated=ss.stsql_updated,\n                available_col_filter=filter_colsname,\n            )\n\n        col_filter = read_cte.ColFilter(\n            self.expander_container,\n            self.cte,\n            existing,\n            filter_colsname,\n            self.base_key,\n        )\n        if str(col_filter) != \"\":\n            self.filter_container.write(col_filter)\n\n        return col_filter\n\n    def pagination(self, qtty_rows: int, col_filter: read_cte.ColFilter):\n        with self.pag_container:\n            items_per_page, page = read_cte.show_pagination(\n                qtty_rows,\n                OPTS_ITEMS_PAGE,\n                self.base_key,\n            )\n\n        filters = {**col_filter.no_dt_filters, **col_filter.dt_filters}\n        if filters != ss.stsql_filters:\n            page = 1\n            ss.stsql_filters = filters\n\n        return items_per_page, page\n\n    def get_initial_balance(self, stmt_no_pag: Select, col_filter: read_cte.ColFilter):\n        if self.rolling_total_column is None:\n            return 0\n\n        saldo_toogle = self.saldo_toggle_col.toggle(\n            f\"Adiciona Saldo Devedor em {self.rolling_pretty_name}\",\n            value=True,\n            key=f\"{self.base_key}_saldo_toggle_sql_ui\",\n        )\n\n        if not saldo_toogle:\n            return 0\n\n        with self.conn.session as s:\n            first_row = s.execute(stmt_no_pag).first()\n\n        first_row_id: int | None = None\n        if first_row and isinstance(first_row.id, int):\n            first_row_id = first_row.id\n\n        no_dt_filters = col_filter.no_dt_filters\n        stmt_no_pag_dt = read_cte.get_stmt_no_pag_dt(self.cte, no_dt_filters)\n\n        with self.conn.session as s:\n            initial_balance = read_cte.initial_balance(\n                _session=s,\n                stmt_no_pag_dt=stmt_no_pag_dt,\n                col_filter=col_filter,\n                rolling_total_column=self.rolling_total_column,\n                first_row_id=first_row_id,\n            )\n\n        self.saldo_value_col.subheader(\n            f\"Saldo Anterior {self.rolling_pretty_name}: {initial_balance:,.2f}\"\n        )\n\n        return initial_balance\n\n    def convert_arrow(self, df: pd.DataFrame):\n        cols = self.cte.columns\n        for col in cols:\n            if isinstance(col.type, SQLEnum):\n                col_name = col.name\n                df[col_name] = df[col_name].map(lambda v: v.value)\n\n        return df\n\n    def get_df(\n        self,\n        stmt_pag: Select,\n        initial_balance: float,\n    ):\n        with self.conn.connect() as c:\n            df = pd.read_sql(stmt_pag, c)\n\n        df = self.convert_arrow(df)\n        if self.rolling_total_column is None:\n            return df\n\n        rolling_col_name = f\"Balance {self.rolling_pretty_name}\"\n        df[rolling_col_name] = df[self.rolling_total_column].cumsum() + initial_balance\n\n        return df\n\n    def add_balance_formatter(self, df_style_formatter: dict[str, str]):\n        formatter = {}\n        for k, v in df_style_formatter.items():\n            formatter[k] = v\n            if k == self.rolling_total_column:\n                rolling_col_name = f\"Balance {self.rolling_pretty_name}\"\n                formatter[rolling_col_name] = v\n\n        return formatter\n\n    def show_df(self, df: pd.DataFrame):\n        if df.empty:\n            st.header(\":red[Tabela Vazia]\")\n            return None\n\n        column_order = None\n        if self.hide_id:\n            column_order = [colname for colname in df.columns if colname != \"id\"]\n\n        df_style = df.style\n        formatter = self.add_balance_formatter(self.df_style_formatter)\n        df_style = df_style.format(formatter)  # pyright: ignore\n        if self.style_fn is not None:\n            df_style = df_style.apply(self.style_fn, axis=1)\n\n        selection_state = self.data_container.dataframe(\n            df_style,\n            use_container_width=self.read_use_container_width,\n            height=650,\n            hide_index=True,\n            column_order=column_order,\n            on_select=\"rerun\",\n            selection_mode=\"multi-row\",\n            key=f\"{self.base_key}_df_sql_ui\",\n        )\n        return selection_state\n\n    def get_rows_selected(self, selection_state: DataframeState | None):\n        rows_pos = []\n        if (\n            selection_state\n            and \"selection\" in selection_state\n            and \"rows\" in selection_state[\"selection\"]\n        ):\n            rows_pos = selection_state[\"selection\"][\"rows\"]\n\n        return rows_pos\n\n    def crud(self, df: pd.DataFrame, rows_selected: list[int]):\n        qtty_rows = len(rows_selected)\n        action = update_model.action_btns(\n            self.btns_container,\n            qtty_rows,\n            ss.stsql_opened,\n        )\n\n        if action == \"add\":\n            create_row = create_delete_model.CreateRow(\n                conn=self.conn,\n                Model=self.edit_create_model,\n                default_values=self.edit_create_default_values,\n            )\n            create_row.show_dialog()\n        elif action == \"edit\":\n            selected_pos = rows_selected[0]\n            row_id = int(df.iloc[selected_pos][\"id\"])\n            update_row = update_model.UpdateRow(\n                conn=self.conn,\n                Model=self.edit_create_model,\n                row_id=row_id,\n                default_values=self.edit_create_default_values,\n                update_show_many=self.update_show_many,\n            )\n            update_row.show_dialog()\n        elif action == \"delete\":\n            rows_id = df.iloc[rows_selected].id.astype(int).to_list()\n            delete_rows = create_delete_model.DeleteRows(\n                conn=self.conn,\n                Model=self.edit_create_model,\n                rows_id=rows_id,\n            )\n            delete_rows.show_dialog()\n</code></pre>"},{"location":"api/#streamlit_sql.SqlUi.__init__","title":"<code>__init__(conn, read_instance, edit_create_model, available_filter=None, edit_create_default_values=None, rolling_total_column=None, df_style_formatter=None, read_use_container_width=False, hide_id=True, base_key='', style_fn=None, update_show_many=False, disable_log=False)</code>","text":"<p>The CRUD interface will be displayes just by initializing the class</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>SQLConnection</code> <p>A sqlalchemy connection created with st.connection(\"sql\", url=\"\") required <code>read_instance</code> <code>Select | CTE | Model</code> <p>The sqlalchemy select statement to display or a CTE. Choose columns to display , join, query or order.If selecting columns, you need to add the id column. If a Model, it will select all columns.</p> required <code>edit_create_default_values</code> <code>dict</code> <p>A dict with column name as keys and values to be default. When the user clicks to create a row, those columns will not show on the form and its value will be added to the Model object</p> <code>None</code> <code>available_filter</code> <code>list[str]</code> <p>Define wich columns the user will be able to filter in the top exapander. Defaults to all</p> <code>None</code> <code>rolling_total_column</code> <code>str</code> <p>A numeric column name of the read_instance. A new column will be displayed with the rolling sum of these column</p> <code>None</code> <code>df_style_formatter</code> <code>dict[str, str]</code> <p>a dictionary where each key is a column name and the associated value is the formatter arg of df.style.format method. See pandas docs for details.</p> <code>None</code> <code>read_use_container_width</code> <code>bool</code> <p>add use_container_width to st.dataframe args. Default to False</p> <code>False</code> <code>hide_id</code> <code>bool</code> <p>The id column will not be displayed if set to True. Defaults to True</p> <code>True</code> <code>base_key</code> <code>str</code> <p>A prefix to add to widget's key argument. This is needed when creating more than one instance of this class in the same page. Defaults to empty str</p> <code>''</code> <code>style_fn</code> <code>Callable[[Series], list[str]]</code> <p>A function that goes into the func argument of df.style.apply. The apply method also receives axis=1, so it works on rows. It can be used to apply conditional css formatting on each column of the row. See Styler.apply info on pandas docs. Defaults to None</p> <code>None</code> <code>update_show_many</code> <code>bool</code> <p>Show a st.expander of one-to-many relations in edit or create dialog</p> <code>False</code> <code>disable_log</code> <code>bool</code> <p>Every change in the database (READ, UPDATE, DELETE) is logged to stderr by default. If this is true, nothing is logged. To customize the logging format and where it logs to, use loguru as add a new sink to logger. See loguru docs for more information. Dafaults to False</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>df</code> <code>Dataframe</code> <p>The Dataframe displayed in the screen</p> <code>selected_rows</code> <code>list[int]</code> <p>The position of selected rows. This is not the row id.</p> <code>qtty_rows</code> <code>int</code> <p>The quantity of all rows after filtering</p> <p>Examples:</p> <pre><code>def style_fn(row):\n    if row.amount &gt; 0:\n        bg = \"background-color: rgba(0, 255, 0, 0.1)\"\n    else:\n        bg = \"background-color: rgba(255, 0, 0, 0.2)\"\n\n    result = [bg] * len(row)\n    return result\n\n\ndb_url = \"sqlite:///data.db\"\nconn = st.connection(\"sql\", db_url)\n\nstmt = (\n    select(\n        db.Invoice.id,\n        db.Invoice.Date,\n        db.Invoice.amount,\n        db.Client.name,\n    )\n    .join(db.Client)\n    .where(db.Invoice.amount &gt; 1000)\n    .order_by(db.Invoice.date)\n)\n\nsql_ui = SqlUi(\n    conn=conn,\n    read_instance=stmt,\n    edit_create_model=db.Invoice,\n    available_filter=[\"name\"],\n    rolling_total_column=\"amount\",\n    df_style_formatter={\"amount\": \"{:,.2f}\"},\n    read_use_container_width=True,\n    hide_id=True,\n    base_key=\"my_base_sql_ui\",\n    style_fn=style_fn,\n    update_show_many=True,\n    disable_log=False,\n)\n</code></pre> Source code in <code>streamlit_sql/sql_iu.py</code> <pre><code>def __init__(\n    self,\n    conn: SQLConnection,\n    read_instance,\n    edit_create_model: type[DeclarativeBase],\n    available_filter: list[str] | None = None,\n    edit_create_default_values: dict | None = None,\n    rolling_total_column: str | None = None,\n    df_style_formatter: dict[str, str] | None = None,\n    read_use_container_width: bool = False,\n    hide_id: bool = True,\n    base_key: str = \"\",\n    style_fn: Callable[[pd.Series], list[str]] | None = None,\n    update_show_many: bool = False,\n    disable_log: bool = False,\n):\n    \"\"\"The CRUD interface will be displayes just by initializing the class\n\n    Arguments:\n        conn (SQLConnection): A sqlalchemy connection created with st.connection(\\\"sql\\\", url=\\\"&lt;sqlalchemy url&gt;\\\")\n        read_instance (Select | CTE | Model): The sqlalchemy select statement to display or a CTE. Choose columns to display , join, query or order.If selecting columns, you need to add the id column. If a Model, it will select all columns.\n        edit_create_default_values (dict, optional): A dict with column name as keys and values to be default. When the user clicks to create a row, those columns will not show on the form and its value will be added to the Model object\n        available_filter (list[str], optional): Define wich columns the user will be able to filter in the top exapander. Defaults to all\n        rolling_total_column (str, optional): A numeric column name of the read_instance. A new column will be displayed with the rolling sum of these column\n        df_style_formatter (dict[str,str]): a dictionary where each key is a column name and the associated value is the formatter arg of df.style.format method. See pandas docs for details.\n        read_use_container_width (bool, optional): add use_container_width to st.dataframe args. Default to False\n        hide_id (bool, optional): The id column will not be displayed if set to True. Defaults to True\n        base_key (str, optional): A prefix to add to widget's key argument. This is needed when creating more than one instance of this class in the same page. Defaults to empty str\n        style_fn (Callable[[pd.Series], list[str]], optional): A function that goes into the *func* argument of *df.style.apply*. The apply method also receives *axis=1*, so it works on rows. It can be used to apply conditional css formatting on each column of the row. See Styler.apply info on pandas docs. Defaults to None\n        update_show_many (bool, optional): Show a st.expander of one-to-many relations in edit or create dialog\n        disable_log (bool): Every change in the database (READ, UPDATE, DELETE) is logged to stderr by default. If this is *true*, nothing is logged. To customize the logging format and where it logs to, use loguru as add a new sink to logger. See loguru docs for more information. Dafaults to False\n\n    Attributes:\n        df (pd.Dataframe): The Dataframe displayed in the screen\n        selected_rows (list[int]): The position of selected rows. This is not the row id.\n        qtty_rows (int): The quantity of all rows after filtering\n\n\n    Examples:\n        ```python\n        def style_fn(row):\n            if row.amount &gt; 0:\n                bg = \"background-color: rgba(0, 255, 0, 0.1)\"\n            else:\n                bg = \"background-color: rgba(255, 0, 0, 0.2)\"\n\n            result = [bg] * len(row)\n            return result\n\n\n        db_url = \"sqlite:///data.db\"\n        conn = st.connection(\"sql\", db_url)\n\n        stmt = (\n            select(\n                db.Invoice.id,\n                db.Invoice.Date,\n                db.Invoice.amount,\n                db.Client.name,\n            )\n            .join(db.Client)\n            .where(db.Invoice.amount &gt; 1000)\n            .order_by(db.Invoice.date)\n        )\n\n        sql_ui = SqlUi(\n            conn=conn,\n            read_instance=stmt,\n            edit_create_model=db.Invoice,\n            available_filter=[\"name\"],\n            rolling_total_column=\"amount\",\n            df_style_formatter={\"amount\": \"{:,.2f}\"},\n            read_use_container_width=True,\n            hide_id=True,\n            base_key=\"my_base_sql_ui\",\n            style_fn=style_fn,\n            update_show_many=True,\n            disable_log=False,\n        )\n\n        ```\n\n    \"\"\"\n    self.conn = conn\n    self.read_instance = read_instance\n    self.edit_create_model = edit_create_model\n    self.available_filter = available_filter or []\n    self.edit_create_default_values = edit_create_default_values or {}\n    self.rolling_total_column = rolling_total_column\n    self.df_style_formatter = df_style_formatter or {}\n    self.read_use_container_width = read_use_container_width\n    self.hide_id = hide_id\n    self.base_key = base_key\n    self.style_fn = style_fn\n    self.update_show_many = update_show_many\n    self.disable_log = disable_log\n\n    self.cte = self.get_cte()\n    self.rolling_pretty_name = lib.get_pretty_name(self.rolling_total_column or \"\")\n\n    # Bootstrap\n    self.set_initial_state()\n    self.set_structure()\n    self.notification()\n    lib.set_logging(self.disable_log)\n\n    # Create UI\n    col_filter = self.filter()\n    stmt_no_pag = read_cte.get_stmt_no_pag(self.cte, col_filter)\n    initial_balance = self.get_initial_balance(stmt_no_pag, col_filter)\n    qtty_rows = read_cte.get_qtty_rows(self.conn, stmt_no_pag)\n    items_per_page, page = self.pagination(qtty_rows, col_filter)\n    stmt_pag = read_cte.get_stmt_pag(stmt_no_pag, items_per_page, page)\n    df = self.get_df(stmt_pag, initial_balance)\n    selection_state = self.show_df(df)\n    rows_selected = self.get_rows_selected(selection_state)\n\n    # CRUD\n    self.crud(df, rows_selected)\n    ss.stsql_opened = False\n\n    # Returns\n    self.df = df\n    self.rows_selected = rows_selected\n    self.qtty_rows = qtty_rows\n</code></pre>"},{"location":"api/#streamlit_sql.show_sql_ui","title":"<code>show_sql_ui(conn, read_instance, edit_create_model, available_filter=None, edit_create_default_values=None, rolling_total_column=None, df_style_formatter=None, read_use_container_width=False, hide_id=True, base_key='', style_fn=None, update_show_many=False)</code>","text":"<p>Show A CRUD interface in a Streamlit Page</p> <p>This function is deprecated and will be removed in future versions. See SqlUi class docs for details on each argument.</p> <p>Returns:      tuple[pd.DataFrame, list[int]]: A Tuple with the DataFrame displayed as first item and a list of rows numbers selected as second item.</p> Example <p>See SqlUi class for an example.</p> Source code in <code>streamlit_sql/sql_iu.py</code> <pre><code>def show_sql_ui(\n    conn: SQLConnection,\n    read_instance,\n    edit_create_model: type[DeclarativeBase],\n    available_filter: list[str] | None = None,\n    edit_create_default_values: dict | None = None,\n    rolling_total_column: str | None = None,\n    df_style_formatter: dict[str, str] | None = None,\n    read_use_container_width: bool = False,\n    hide_id: bool = True,\n    base_key: str = \"\",\n    style_fn: Callable[[pd.Series], list[str]] | None = None,\n    update_show_many: bool = False,\n) -&gt; tuple[pd.DataFrame, list[int]] | None:\n    \"\"\"Show A CRUD interface in a Streamlit Page\n\n    This function is deprecated and will be removed in future versions. See SqlUi class docs for details on each argument.\n\n     Returns:\n         tuple[pd.DataFrame, list[int]]: A Tuple with the DataFrame displayed as first item and a list of rows numbers selected as second item.\n\n    Example:\n        See SqlUi class for an example.\n\n    \"\"\"\n    ui = SqlUi(\n        conn=conn,\n        read_instance=read_instance,\n        edit_create_model=edit_create_model,\n        available_filter=available_filter,\n        edit_create_default_values=edit_create_default_values,\n        rolling_total_column=rolling_total_column,\n        df_style_formatter=df_style_formatter,\n        read_use_container_width=read_use_container_width,\n        hide_id=hide_id,\n        base_key=base_key,\n        style_fn=style_fn,\n        update_show_many=update_show_many,\n    )\n\n    return ui.df, ui.rows_selected\n</code></pre>"}]}